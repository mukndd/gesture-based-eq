# Requirements:
# pip install PyQt5 mediapipe opencv-python numpy
import sys, os, time, math, json, random
from pathlib import Path
from functools import partial
import numpy as np
import cv2
import mediapipe as mp
from PyQt5 import QtWidgets, QtCore, QtGui
from PyQt5.QtCore import Qt

STATE_FILE = "eq_state.json"
SAVED_PRESET_FILE = "saved_preset.json"
EQUALIZER_APO_CONFIG = r"C:\\Program Files\\EqualizerAPO\\config\\config.txt"
BAND_CENTERS = [62, 110, 250, 370, 650, 1200, 2130, 4550, 6850, 16000]
BAND_LABELS = [
    "Sub-Bass", "Bass", "Low-Mids", "Mids", "Upper-Mids",
    "Vocals", "High-Mids", "Treble", "Presence", "Air"
]
MIN_DB, MAX_DB = -24.0, 24.0

FRAME_W, FRAME_H = 640, 360

PINCH_THRESHOLD = 0.08
PINCH_HOLD_MS = 120
L_SHAPE_MIN_DIST = 0.12
SMOOTH_ALPHA = 0.6
COOLDOWN = 0.02

# LEFT gestures : thumb=5, index=1, middle=2, ring=3, pinky=4
LEFT_GESTURES = [
    (1,), (1,2), (1,2,3), (1,2,3,4), (1,2,3,4,5),
    (5,), (1,5), (1,2,5), (1,2,3,5), ()   # fist -> ()
]

EXIT_HOLD_MS = 800

mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils

SELECTED_GESTURES = [tuple(g) for g in LEFT_GESTURES]
GESTURE_TO_BAND = {tuple(sorted(g)): i for i,g in enumerate(SELECTED_GESTURES)}

def load_state():
    p = Path(STATE_FILE)
    if p.exists():
        try:
            return json.loads(p.read_text())
        except:
            pass
    return {"gains":[0.0]*10,"selected":None,"locked":[False]*10}

def save_state(s):
    Path(STATE_FILE).write_text(json.dumps(s, indent=2))

def percent_to_db(p): return MIN_DB + (MAX_DB - MIN_DB) * p
def db_to_percent(db): return (db - MIN_DB) / (MAX_DB - MIN_DB)

def write_eqapo(gains):
    path = EQUALIZER_APO_CONFIG
    try:
        header = ["# Auto-generated by gesture_eq_with_embedded_camera_and_default.py", "Preamp: 0 dB"]
        q_default = 1.0
        lines = []
        for i, (fc, g) in enumerate(zip(BAND_CENTERS, gains), start=1):
            lines.append(f"Filter {i}: ON PK Fc {int(fc)} Hz Gain {g:.2f} dB Q {q_default:.2f}")
        txt = "\n".join(header + lines) + "\n"
        with open(path, "w", encoding="utf-8") as f:
            f.write(txt)
        return True
    except Exception as e:
        print("APO write failed:", e)
        return False

# ---------- GUI ----------
class CompactEQ(QtWidgets.QWidget):
    frame_requested = QtCore.pyqtSignal()  # placeholder if needed

    def __init__(self, state):
        super().__init__()
        self.setStyleSheet("""
            QWidget {
                background-color: #0E0E0E;
                color: #FFFFFF;
                font-family: 'Segoe UI', sans-serif;
            }

            QLabel {
                color: #FFFFFF;
                font-weight: 500;
            }

            QPushButton {
                background-color: #181818;
                border: 1px solid #333333;
                border-radius: 6px;
                padding: 6px;
                color: #FFFFFF;
                font-weight: 600;
            }

            QPushButton:hover {
                background-color: #00C8FF;
                color: #000000;
                font-weight: bold;
            }

            QSlider::groove:vertical {
                background: #333333;
                width: 8px;
                border-radius: 4px;
            }

            QSlider::sub-page:vertical {
                background: #00C8FF;
                border-radius: 4px;
            }

            QSlider::handle:vertical {
                background: #00C8FF;
                height: 18px;
                margin: -5px;
                border-radius: 6px;
            }

            QScrollBar:vertical {
                border: none;
                background: #0E0E0E;
                width: 10px;
                margin: 15px 0 15px 0;
            }

            QScrollBar::handle:vertical {
                background: #333333;
                min-height: 30px;
                border-radius: 5px;
            }

            QScrollBar::handle:vertical:hover {
                background: #00C8FF;
            }
        """)
        self.state = state
        self.setWindowTitle("Mukund's Equalizer")
        self.setGeometry(80,60,1400,640)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)
        root = QtWidgets.QHBoxLayout()
        self.sliders = []

        # Left: sliders area (expandable)
        sliders_area = QtWidgets.QHBoxLayout()
        for i, (f, label) in enumerate(zip(BAND_CENTERS, BAND_LABELS)):
            v = QtWidgets.QVBoxLayout()
            name = QtWidgets.QLabel(f"{i+1}\n{f} Hz\n{label}")
            name.setAlignment(Qt.AlignCenter)
            s = QtWidgets.QSlider(Qt.Vertical)
            s.setMinimum(0); s.setMaximum(1000)
            s.setValue(int(db_to_percent(self.state["gains"][i])*1000))
            s.valueChanged.connect(partial(self.on_slider,i))
            val = QtWidgets.QLabel(f"{self.state['gains'][i]:.2f} dB")
            val.setAlignment(Qt.AlignCenter)
            v.addWidget(name); v.addWidget(s,stretch=1); v.addWidget(val)
            sliders_area.addLayout(v)
            self.sliders.append((s,val,name))
        root.addLayout(sliders_area, stretch=3)

        # Right: camera + controls
        right = QtWidgets.QVBoxLayout()

        # Camera placeholder box (resizable)
        self.cam_label = QtWidgets.QLabel()
        self.cam_label.setMinimumSize(320,200)
        self.cam_label.setAlignment(Qt.AlignCenter)
        self.cam_label.setStyleSheet("background:#222; color:#ddd; border:1px solid #444;")
        placeholder = QtGui.QPixmap(320,200)
        placeholder.fill(QtGui.QColor("black"))
        ph_text = QtGui.QPainter(placeholder)
        ph_text.setPen(QtGui.QPen(QtGui.QColor("white")))
        ph_text.drawText(placeholder.rect(), Qt.AlignCenter, "Camera feed\n(initializing...)")
        ph_text.end()
        self.cam_label.setPixmap(placeholder)
        right.addWidget(self.cam_label, stretch=2)

        # Info label
        self.info = QtWidgets.QLabel(self.info_text())
        right.addWidget(self.info)

        # Buttons
        btn_save = QtWidgets.QPushButton("Save Current Preset")
        btn_apply = QtWidgets.QPushButton("Apply Saved Preset")
        btn_random = QtWidgets.QPushButton("Randomize")
        btn_default = QtWidgets.QPushButton("Set to Default")

        right.addWidget(btn_save)
        right.addWidget(btn_apply)
        right.addWidget(btn_random)
        right.addWidget(btn_default)

        self.preset_label = QtWidgets.QLabel(self.preset_text())
        right.addWidget(self.preset_label)

        right.addStretch()
        root.addLayout(right, stretch=1)

        self.setLayout(root)
        self.refresh_ui()

        # expose buttons for Controller to connect
        self.btn_save = btn_save
        self.btn_apply = btn_apply
        self.btn_random = btn_random
        self.btn_default = btn_default

    def info_text(self):
        sel = self.state.get("selected", None)
        if sel is None:
            return "Selected: None"
        return f"Selected: {sel+1} | {BAND_LABELS[sel]} | {self.state['gains'][sel]:.2f} dB | Locked: {self.state['locked'][sel]}"

    def preset_text(self):
        p = Path(SAVED_PRESET_FILE)
        if not p.exists():
            return "Preset: (none)"
        try:
            data = json.loads(p.read_text())
            return f"Preset: saved ({len(data.get('gains',[]))} bands)"
        except:
            return "Preset: (invalid)"

    def on_slider(self,i,val):
        db = percent_to_db(val/1000.0)
        self.state["gains"][i] = db
        self.sliders[i][1].setText(f"{db:.2f} dB")
        save_state(self.state)
        write_eqapo(self.state["gains"])
        self.info.setText(self.info_text())
        self.preset_label.setText(self.preset_text())

    def set_db_from_gesture(self,i,db):
        if i is None: return
        self.state["gains"][i]=db
        self.sliders[i][0].blockSignals(True)
        self.sliders[i][0].setValue(int(db_to_percent(db)*1000))
        self.sliders[i][0].blockSignals(False)
        self.sliders[i][1].setText(f"{db:.2f} dB")
        save_state(self.state); write_eqapo(self.state["gains"])
        self.info.setText(self.info_text())
        self.preset_label.setText(self.preset_text())

    def set_selected(self,idx):
        self.state["selected"]=idx
        save_state(self.state)
        self.refresh_ui(); self.info.setText(self.info_text())

    def refresh_ui(self):
        sel = self.state.get("selected", None)
        for i,(_,_,lab) in enumerate(self.sliders):
            if sel is not None and i==sel:
                lab.setStyleSheet("font-weight:bold;color:cyan;")
            else:
                lab.setStyleSheet("color:black;")

    # update camera pixmap from numpy BGR frame
    def update_cam_frame(self, bgr_frame):
        # convert to rgb
        try:
            rgb = cv2.cvtColor(bgr_frame, cv2.COLOR_BGR2RGB)
            h, w, ch = rgb.shape
            bytes_per_line = ch * w
            qimg = QtGui.QImage(rgb.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
            # scale to label while keeping aspect
            pix = QtGui.QPixmap.fromImage(qimg).scaled(self.cam_label.width(), self.cam_label.height(), Qt.KeepAspectRatio)
            self.cam_label.setPixmap(pix)
        except Exception as e:
            # ignore conversion errors
            pass

    def resizeEvent(self, ev):
        # when resizing, ensure camera frame scales
        cur = self.cam_label.pixmap()
        if cur:
            self.cam_label.setPixmap(cur.scaled(self.cam_label.width(), self.cam_label.height(), Qt.KeepAspectRatio))
        super().resizeEvent(ev)

# ---------- Gesture thread ----------
class GestureThread(QtCore.QThread):
    emit_db = QtCore.pyqtSignal(int,float)
    emit_sel = QtCore.pyqtSignal(object)  # can be int or None
    emit_lock = QtCore.pyqtSignal(int,bool)
    emit_exit_keep = QtCore.pyqtSignal()
    emit_exit_reset = QtCore.pyqtSignal()
    emit_frame = QtCore.pyqtSignal(object)  # emits numpy BGR frame

    def __init__(self, state):
        super().__init__()
        self.state = state
        self.running = True

    def stop(self):
        self.running = False

    def run(self):
        cap = cv2.VideoCapture(0)
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_W)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_H)

        hands = mp_hands.Hands(
            static_image_mode=False,
            max_num_hands=int(2),
            model_complexity=int(1),
            min_detection_confidence=float(0.6),
            min_tracking_confidence=float(0.5)
        )

        pinch_start = None; engaged = False; y0 = None; db0 = None
        l_start = None; l_toggled = False; last_apply = 0.0
        left_exit_start = None; left_reset_start = None

        while self.running:
            ret, frame = cap.read()
            if not ret:
                time.sleep(0.02); continue
            frame = cv2.flip(frame, 1)
            rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            res = hands.process(rgb)
            h,w,_ = frame.shape
            left = None; right = None
            if getattr(res, "multi_hand_landmarks", None) and getattr(res, "multi_handedness", None):
                for lm,handed in zip(res.multi_hand_landmarks, res.multi_handedness):
                    label = handed.classification[0].label
                    fset = self.fingers_up(lm, label)
                    if label == "Left":
                        left = tuple(sorted(fset))
                    else:
                        right = (lm, tuple(sorted(fset)))
                    # draw landmarks on BGR frame for display
                    mp_drawing.draw_landmarks(frame, lm, mp_hands.HAND_CONNECTIONS)

            # emit frame for GUI
            try:
                self.emit_frame.emit(frame.copy())
            except Exception:
                pass

            # EXIT / RESET detection
            if left == tuple(sorted((1,4))):
                if left_exit_start is None:
                    left_exit_start = time.time()
                else:
                    if (time.time() - left_exit_start) * 1000 >= EXIT_HOLD_MS:
                        self.emit_exit_keep.emit(); break
            else:
                left_exit_start = None

            if left == tuple(sorted((5,1,4))):
                if left_reset_start is None:
                    left_reset_start = time.time()
                else:
                    if (time.time() - left_reset_start) * 1000 >= EXIT_HOLD_MS:
                        self.emit_exit_reset.emit(); break
            else:
                left_reset_start = None

            # selection
            if left is not None:
                left_key = tuple(sorted(left))
                if left_key in GESTURE_TO_BAND:
                    idx = GESTURE_TO_BAND[left_key]
                    if idx != self.state.get("selected", None):
                        self.state["selected"] = idx; save_state(self.state); self.emit_sel.emit(idx)

            # right control pinch / L-shape
            if right is not None:
                lm, rf = right
                d_norm, mid_y = self.index_thumb_info(lm, w, h)
                if set(rf) == {1,5} and d_norm > L_SHAPE_MIN_DIST:
                    now = time.time()
                    if l_start is None:
                        l_start = now
                    elif (now - l_start) * 1000 >= 280 and not l_toggled:
                        sel = self.state.get("selected", None)
                        if sel is not None:
                            self.state["locked"][sel] = not self.state["locked"][sel]
                            save_state(self.state); self.emit_lock.emit(sel, self.state["locked"][sel]); l_toggled = True
                else:
                    l_start = None; l_toggled = False

                if d_norm < PINCH_THRESHOLD:
                    now = time.time()
                    if not engaged:
                        if pinch_start is None:
                            pinch_start = now
                            if self.state.get("selected", None) is None:
                                pinch_start = None
                            else:
                                y0 = mid_y; db0 = self.state["gains"][self.state["selected"]]
                        elif (now - pinch_start) * 1000 >= PINCH_HOLD_MS:
                            engaged = True
                    else:
                        sel = self.state.get("selected", None)
                        if sel is not None:
                            dy = y0 - mid_y
                            span = (MAX_DB - MIN_DB)
                            frac = max(-1.0, min(1.0, dy / (h * 0.5)))
                            raw_db = db0 + frac * span
                            if not self.state["locked"][sel] and (time.time() - last_apply) >= COOLDOWN:
                                cur = self.state["gains"][sel]
                                new = cur + (raw_db - cur) * SMOOTH_ALPHA
                                new = max(MIN_DB, min(MAX_DB, new))
                                self.state["gains"][sel] = new
                                save_state(self.state)
                                self.emit_db.emit(sel, new)
                                last_apply = time.time()
                else:
                    pinch_start = None; engaged = False
            else:
                pinch_start = None; engaged = False; l_start = None; l_toggled = False

            time.sleep(0.004)

        cap.release(); hands.close()

    def fingers_up(self, lm_obj, handed):
        lm = lm_obj.landmark; out = []
        if handed == "Right":
            if lm[4].x < lm[3].x - 0.01: out.append(5)
        else:
            if lm[4].x > lm[3].x + 0.01: out.append(5)
        tips = [8,12,16,20]; pips = [6,10,14,18]; mapu = {8:1,12:2,16:3,20:4}
        for t,p in zip(tips,pips):
            if lm[t].y < lm[p].y - 0.02:
                out.append(mapu[t])
        return out

    def index_thumb_info(self, lm_obj, fw, fh):
        lm = lm_obj.landmark
        ix, iy = int(lm[8].x * fw), int(lm[8].y * fh)
        tx, ty = int(lm[4].x * fw), int(lm[4].y * fh)
        midy = (iy + ty) / 2.0
        dist = math.hypot(ix - tx, iy - ty)
        diag = math.hypot(fw, fh)
        return dist / diag, midy

# ---------- Controller ----------
class Controller(QtCore.QObject):
    def __init__(self):
        super().__init__()
        self.state = load_state()
        if len(self.state["gains"]) != len(BAND_CENTERS):
            self.state["gains"] = [0.0]*len(BAND_CENTERS)
        if "locked" not in self.state or len(self.state["locked"]) != len(BAND_CENTERS):
            self.state["locked"] = [False]*len(BAND_CENTERS)

        self.qt = QtWidgets.QApplication(sys.argv)
        self.win = CompactEQ(self.state)
        self.gthread = GestureThread(self.state)
        self.gthread.emit_db.connect(self.update_db)
        self.gthread.emit_sel.connect(self.update_sel)
        self.gthread.emit_lock.connect(self.on_lock)
        self.gthread.emit_exit_keep.connect(self.on_exit_keep)
        self.gthread.emit_exit_reset.connect(self.on_exit_reset)
        self.gthread.emit_frame.connect(self.on_frame)
        self.gthread.start()

        # connect buttons
        self.win.btn_save.clicked.connect(self.save_preset)
        self.win.btn_apply.clicked.connect(self.apply_saved_preset_magic)
        self.win.btn_random.clicked.connect(self.randomize_smooth)
        self.win.btn_default.clicked.connect(self.set_to_default_smooth)

        # animation config
        self._anim_timer = None
        self._anim_steps = 40
        self._anim_interval = 20  # ms

    def on_frame(self, frame):
        # Update GUI cam label
        self.win.update_cam_frame(frame)

    def update_db(self, idx, db):
        QtCore.QTimer.singleShot(0, lambda idx=idx, db=db: self.win.set_db_from_gesture(idx, db))

    def update_sel(self, idx):
        QtCore.QTimer.singleShot(0, lambda idx=idx: self.win.set_selected(idx))

    def on_lock(self, idx, val):
        QtCore.QTimer.singleShot(0, lambda: self.win.info.setText(self.win.info_text()))

    def save_preset(self):
        preset = {"gains": self.state["gains"]}
        try:
            Path(SAVED_PRESET_FILE).write_text(json.dumps(preset, indent=2))
            self.win.preset_label.setText(self.win.preset_text())
            print("Preset saved.")
        except Exception as e:
            print()
            #print("Preset save failed:", e)

    def load_saved_preset(self):
        p = Path(SAVED_PRESET_FILE)
        if not p.exists(): return None
        try:
            obj = json.loads(p.read_text())
            gains = obj.get("gains")
            if gains and len(gains) == len(BAND_CENTERS):
                return gains
        except:
            pass
        return None

    def apply_saved_preset_magic(self):
        target = self.load_saved_preset()
        if target is None:
            print("No saved preset found.")
            return
        current = list(self.state["gains"])
        target = [max(MIN_DB, min(MAX_DB, g)) for g in target]
        self.animate_to_targets(current, target)

    def randomize_smooth(self):
        targets = [random.uniform(-20.0, 20.0) for _ in BAND_CENTERS]
        current = list(self.state["gains"])
        self.animate_to_targets(current, targets)

    def set_to_default_smooth(self):
        targets = [0.0 for _ in BAND_CENTERS]
        current = list(self.state["gains"])
        self.animate_to_targets(current, targets)

    def animate_to_targets(self, start_gains, target_gains, steps=None, interval_ms=None):
        if self._anim_timer is not None:
            self._anim_timer.stop()
            self._anim_timer.deleteLater()
            self._anim_timer = None

        steps = steps or self._anim_steps
        interval_ms = interval_ms or self._anim_interval
        diffs = [t - s for s,t in zip(start_gains, target_gains)]
        increment = [d/steps for d in diffs]
        step_idx = {"i": 0}

        def step():
            i = step_idx["i"]
            if i >= steps:
                # finalize
                for j,val in enumerate(target_gains):
                    self.state["gains"][j] = val
                    QtCore.QTimer.singleShot(0, lambda j=j, val=val: self.win.set_db_from_gesture(j, val))
                save_state(self.state); write_eqapo(self.state["gains"])
                if self._anim_timer is not None:
                    self._anim_timer.stop(); self._anim_timer.deleteLater(); self._anim_timer = None
                return
            for j in range(len(self.state["gains"])):
                newv = self.state["gains"][j] + increment[j]
                newv = max(MIN_DB, min(MAX_DB, newv))
                self.state["gains"][j] = newv
                QtCore.QTimer.singleShot(0, lambda j=j, val=newv: self.win.set_db_from_gesture(j, val))
            if (i % 4) == 0:
                write_eqapo(self.state["gains"]); save_state(self.state)
            step_idx["i"] += 1

        self._anim_timer = QtCore.QTimer()
        self._anim_timer.timeout.connect(step)
        self._anim_timer.start(interval_ms)

    def on_exit_keep(self):
        write_eqapo(self.state["gains"]); save_state(self.state)
        QtCore.QTimer.singleShot(50, lambda: os._exit(0))

    def on_exit_reset(self):
        self.state["gains"] = [0.0]*len(BAND_CENTERS)
        save_state(self.state); write_eqapo(self.state["gains"])
        QtCore.QTimer.singleShot(50, lambda: os._exit(0))

    def run(self):
        self.win.show()
        write_eqapo(self.state["gains"]); save_state(self.state)
        try:
            sys.exit(self.qt.exec_())
        finally:
            self.gthread.stop()

if __name__ == "__main__":
    Controller().run()
